import os  # for the environment variables
import uuid  # for unique id generation
import re  # For use with regular expressions
import requests
from fastapi import FastAPI, HTTPException  # pylint: disable=import-error
from subprocess import run
import logging
import sys
import time
import swagger_client
from azure.storage.blob import BlobServiceClient, BlobClient, ContainerClient


app = FastAPI()

SUBSCRIPTION_KEY = "9f4badcb741c498a8a5157b41585a821"
SERVICE_REGION = "uksouth"
NAME = "Simple transcription"
DESCRIPTION = "Simple transcription description"
LOCALE = "en-US"
RECORDINGS_BLOB_URI = "<Your SAS Uri to the recording>"
RECORDINGS_CONTAINER_URI = "https://tiamataudioin.blob.core.windows.net/audio?sp=rl&st=2023-05-05T09:43:23Z&se=2023-05-05T17:43:23Z&spr=https&sv=2022-11-02&sr=c&sig=qGKm%2BiuwD%2BVYwvipY9BCVEhSIe1Sb4CbFNJKc2XmChk%3D"
STORAGE_ACCOUNT = "rg-tiamat"
CONNECTION_STRING = "DefaultEndpointsProtocol=https;AccountName=tiamataudioin;AccountKey=+jm1JoRK1S7xnivK38o890h4Qo/AXIqWUzxDAK4P/6CZ54HbJ4gY+I0XKGzpb8Kr2ck9GuTBeh3L+AStO3LRoQ==;EndpointSuffix=core.windows.net"
CONTAINER_NAME = 'audio'

# configure API key authorization: subscription_key
configuration = swagger_client.Configuration()
configuration.api_key["Ocp-Apim-Subscription-Key"] = SUBSCRIPTION_KEY
configuration.host = f"https://{SERVICE_REGION}.api.cognitive.microsoft.com/speechtotext/v3.1"
logging.info(f"API Key Configuration")
# create the client object and authenticate
client = swagger_client.ApiClient(configuration)
logging.info(f"Client Object Creation and Authentication")
# create an instance of the transcription api class
api = swagger_client.CustomSpeechTranscriptionsApi(api_client=client)

def transcribe_from_container(uri, properties):
    """
    Transcribe all files in the container located at `uri` using the settings specified in `properties`
    using the base model for the specified locale.
    """
    transcription_definition = swagger_client.Transcription(
        display_name=NAME,
        description=DESCRIPTION,
        locale=LOCALE,
        content_container_url=uri,
        properties=properties
    )

    return transcription_definition

def _paginate(api, paginated_object):
    """
    The autogenerated client does not support pagination. This function returns a generator over
    all items of the array that the paginated object `paginated_object` is part of.
    """
    yield from paginated_object.values
    typename = type(paginated_object).__name__
    auth_settings = ["api_key"]
    while paginated_object.next_link:
        link = paginated_object.next_link[len(api.api_client.configuration.host):]
        paginated_object, status, headers = api.api_client.call_api(link, "GET",
            response_type=typename, auth_settings=auth_settings)

        if status == 200:
            yield from paginated_object.values
        else:
            raise Exception(f"could not receive paginated data: status {status}")


@app.get("/")
def read_root():
    """This tells me that the API is working"""
    return {"Hello": "Tiamat have a working API"}

@app.post("/transcribe/start")
def transcribe():  #sub_key:str, region:str, container_uri:str
    """This will transcribe all audio files from a specified container"""

    logging.info("Starting transcription client...")

    logging.info(f"Transcription API Class instance")
    properties = swagger_client.TranscriptionProperties()

    transcription_definition = transcribe_from_container(RECORDINGS_CONTAINER_URI, properties)
    logging.info(f"Transcribe from container method run")

    created_transcription, status, headers = api.transcriptions_create_with_http_info(transcription=transcription_definition)

    # get the transcription Id from the location URI
    transcription_id = headers["location"].split("/")[-1]
    logging.info(f"Transaction ID from Location URI")

    # Log information about the created transcription. If you should ask for support, please
    # include this information.
    logging.info(f"Created new transcription with id '{transcription_id}' in region {SERVICE_REGION}")

    return (f"Created new transcription with id '{transcription_id}' in region {SERVICE_REGION}")

@app.get("/transcribe/status")
def transcription_status(transcription_id: str):
    """Get the transcription job """

    transcription = api.transcriptions_get(transcription_id)
    logging.info(f"Transcriptions status: {transcription.status}")

    return (f"Transcriptions status: {transcription.status}")
    
@app.get("/transcription/file")
def transcription_file(transcription_id: str):
    """Creates the transcription test file"""

    transcription = api.transcriptions_get(transcription_id)
    
    if transcription.status == "Succeeded":
            pag_files = api.transcriptions_list_files(transcription_id)
            for file_data in _paginate(api, pag_files):
                if file_data.kind != "Transcription":
                    continue

                audiofilename = file_data.name
                results_url = file_data.links.content_url
                results = requests.get(results_url)
                logging.info(f"Results for {audiofilename}:\n{results.content.decode('utf-8')}")
                f = open("transcription.txt", "a")
                f.write(results.content.decode('utf-8'))
                f.close

                logging.info("Starting upload")

                blob_service_client = BlobServiceClient.from_connection_string(CONNECTION_STRING)
                container_client = blob_service_client.get_container_client(CONTAINER_NAME)
                blob_client = container_client.get_blob_client("transcription.txt")

                logging.info("Blob client set up")

                with open("transcription.txt", "rb") as data:
                    blob_client.upload_blob(data, overwrite = True)
                
                return(f"File transcription.txt uploaded to Azure Blob Storage")

    else:
        return ("No successful transcript created")

